---
title: 第十章- 安全的MPI程序
date: 2021-06-02
categories:
 - HPC
tags:
 - MPI
sidebar: 'auto'
---

编写MPI程序, 如果通信调用的顺序使用的不当, 很容易造成死锁. 比如如下所示的例子总会死锁:

![dangerous1](/mpi/cp10-1.png)

进程0的第一条接收语句A能否完成取决于进程1的第二条发送语句D, 即A依赖于D. 从执
行次序上可以明显地看出, 进程0向进程1发送消息的语句C的执行又依赖于它前面的接收语
句A的完成, 即C依赖于A. 同时, 进程1的第一条接收语句B能否完成取决于进程0的第二条发
送语句C的执行, 即B依赖于C. 从执行次序上可以明显地看出, 向进程0发送消息的语句D的执行又依赖于B的完成, 故有A依赖于D, 而D又依赖于B, B依赖于C, C依赖于A, 形成了一个
环. 进程0和进程1相互等待, 彼此都无法执行下去, 必然导致死锁.
若两个进程需要相互交换数据, 在两个进程中首先都进行接收调用显然是不合适的. 那
么, 同时先进行发送调用的结果又是怎样的呢

![dangerous2](/mpi/cp10-2.png)

由于进程0或进程1的发送需要系统提供缓冲区, 在MPI的四种通信模式中有详细的解
释, 如果系统缓冲区不足, 则进程0或进程1的发送将无法完成. 相应的, 进程1和进程0的
接收也无法正确完成. 显然对于需要相互交换数据的进程, 直接将两个发送语句写在前面也
是不安全的.

下面介绍一种可以保证消息安全传递的通信调用次序, 即当两个进程需要相互
交换数据时, 一定要将它们的发送和接收操作按照次序进行匹配, 即一个进程的发送操作在前, 接收操作在后, 而另一个进程的接收操作在前, 发送操作在后, 前后两个发送和接收操作要相互匹配

![safe](/mpi/cp10-3.png)

C的完成只需要A完成, 而A的完成只要有对应的D存在, 则不需要系统提供缓冲区也可
以进行, 这里恰恰满足这样的条件. 因此A总能够完成, 因此D也一定能完成. 当A和D完成
后, B的完成只需要相应的C, 不需要缓冲区也能完成, 因此B和C也一定能完成. 所以说这
样的通信形式是安全的. 显然A和C/D和B同时互换, 从原理上说和这种情况是一样的, 因
此也是安全的.
